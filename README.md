# Кастомизация TCP-стека и маршрутизация трафика

## Описание проекта

Данный проект представляет собой инструмент для изменения TCP-отпечатка (TCP fingerprint) исходящих соединений и настройки маршрутизации трафика через альтернативный сетевой интерфейс (TUN). Основная задача - модификация параметров TCP-соединения таким образом, чтобы изменить сетевой отпечаток системы, имитируя другую операционную систему, и обеспечить маршрутизацию трафика через созданный TUN-интерфейс.

## Функциональность

Проект предоставляет следующие возможности:

**Кастомизация TCP-стека**:
- Изменение параметров TCP-соединения, включая Window Size, TTL
- Удаление опции Timestamps для изменения сетевого отпечатка
- Имитация TCP-отпечатка различных ОС (Windows, macOS, Linux)

**Маршрутизация через TUN-интерфейс**:
- Создание виртуального TUN-интерфейса
- Настройка правил iptables для маркировки пакетов
- Настройка маршрутизации для перенаправления трафика через TUN-интерфейс

**Анализ и мониторинг трафика**:
- Захват сетевого трафика с помощью tcpdump
- Анализ TCP-отпечатка исходящих соединений

## Особенности реализации

В процессе разработки было принято решение использовать системные вызовы и команды для управления сетевым стеком вместо библиотеки gVisor. Причина этого решения - проблемы совместимости и сложности интеграции gVisor с существующим кодом. Основные операции выполняются через следующие средства:

- Использование `sysctl` для изменения параметров TCP-стека
- Применение команд `ip` для создания и настройки TUN-интерфейса
- Использование `iptables` для маркировки и перенаправления трафика
- Применение `tcpdump` для захвата и анализа трафика

Такой подход делает решение более универсальным и менее зависимым от сторонних библиотек, но при этом сохраняет всю необходимую функциональность.

## Изменение TCP-отпечатка

В рамках проекта реализована возможность имитации TCP-отпечатка различных операционных систем. Для каждой ОС предусмотрен свой набор параметров:

**Windows**:
- Отключенные TCP timestamps
- TTL = 128 (по умолчанию)
- Window Size = 8192 (по умолчанию)
- Включенный Window Scale (значение 8)
- MSS = 1460

**macOS**:
- Включенные TCP timestamps
- TTL = 64 (по умолчанию)
- Window Size = 8192 (по умолчанию)
- Включенный Window Scale (значение 6)
- MSS = 1460

**Linux**:
- Включенные TCP timestamps
- TTL = 64 (по умолчанию)
- Window Size = 8192 (по умолчанию)
- Включенный Window Scale (значение 7)
- MSS = 1460

Эти параметры реализованы в функции `GetSystemTCPOptions` в файле `fingerprint.go` и применяются в функции `ConfigureTCPFingerprint`.

## Настройка маршрутизации

Маршрутизация трафика через TUN-интерфейс реализована следующим образом:

1. **Создание и настройка TUN-интерфейса**:
   ```
   ip tuntap add dev tun0 mode tun
   ip link set dev tun0 mtu 1500
   ip link set dev tun0 up
   ip addr add 10.0.0.1/24 dev tun0
   ```

2. **Маркировка пакетов с помощью iptables**:
   ```
   iptables -t filter -A INPUT -p tcp --dport 8081 -j ACCEPT
   iptables -t mangle -A OUTPUT -p tcp --sport 8081 -j MARK --set-mark 0x1337
   iptables -t mangle -A OUTPUT -p tcp -d example.com -j MARK --set-mark 0x1337
   iptables -t filter -A FORWARD -i lo -o tun0 -m mark --mark 0x1337 -j ACCEPT
   iptables -t filter -A FORWARD -i tun0 -o lo -m mark --mark 0x1337 -j ACCEPT
   iptables -t nat -A POSTROUTING -o tun0 -j MASQUERADE
   ```

3. **Настройка таблицы маршрутизации**:
   ```
   ip rule add fwmark 0x1337 table 100
   ip route add $TARGET_IP dev tun0 table 100
   ip route add default via 10.0.0.1 dev tun0 table 100
   ```

Где:
- `0x1337` - метка для пакетов нашего приложения
- `table 100` - дополнительная таблица маршрутизации для маркированных пакетов
- `$TARGET_IP` - IP-адрес целевого хоста (например, example.com)

## Требования

- Операционная система Linux (протестировано на Ubuntu 20.04)
- Go 1.18 или выше
- Права суперпользователя (sudo)
- Установленные пакеты:
    - iptables
    - iproute2
    - tcpdump
    - tshark (опционально, для анализа захваченного трафика)

## Установка и запуск

### Запуск из исходного кода

1. Клонирование репозитория:
   ```bash
   git clone https://github.com/Jamokhon5/custom-tcp-fingerprint.git
   cd custom-tcp-fingerprint
   ```

2. Сборка проекта:
   ```bash
   go build -o tcpcustom ./cmd/tcpcustom
   ```

3. Запуск приложения (необходимы права суперпользователя):
   ```bash
   sudo ./tcpcustom --host example.com --port 80 --fp windows --lport 8082 --tun tun0 --capture ./captures/traffic.pcap
   ```

   Доступные параметры:
    - `--host` - целевой хост (по умолчанию example.com)
    - `--port` - целевой порт (по умолчанию 80)
    - `--fp` - TCP отпечаток для имитации (windows, macos, linux)
    - `--lport` - локальный порт для прослушивания (по умолчанию 8080)
    - `--tun` - имя TUN-интерфейса (по умолчанию tun0)
    - `--ttl` - значение TTL (по умолчанию 64)
    - `--window` - размер TCP окна (по умолчанию 8192)
    - `--mtu` - значение MTU (по умолчанию 1500)
    - `--capture` - файл для захвата трафика (опционально)

### Запуск с использованием Docker

1. Сборка Docker-образа:
   ```bash
   docker build -t tcpcustom .
   ```

2. Запуск контейнера:
   ```bash
   docker run --rm --name tcpcustom --privileged --cap-add=NET_ADMIN --cap-add=NET_RAW --device /dev/net/tun:/dev/net/tun -p 8081:8081 -v $(pwd)/captures:/root/captures tcpcustom --host example.com --port 80 --fp windows --lport 8081 --tun tun0 --capture /root/captures/traffic.pcap
   ```

   Или через docker-compose:
   ```bash
   docker compose up -d
   ```

## Тестирование

После запуска приложения можно проверить его работу следующим образом:

1. Убедиться, что приложение запущено и слушает указанный порт:
   ```bash
   netstat -tuln | grep 8082
   ```

2. Проверить создание TUN-интерфейса:
   ```bash
   ip addr show tun0
   ```

3. Отправить HTTP-запрос через приложение:
   ```bash
   curl http://localhost:8082
   ```

4. Проверить настройки TCP:
   ```bash
   cat /proc/sys/net/ipv4/ip_default_ttl
   cat /proc/sys/net/ipv4/tcp_timestamps
   ```

5. Проверить правила iptables:
   ```bash
   iptables -t mangle -L -v
   ```

6. Анализировать захваченный трафик:
   ```bash
   tcpdump -r ./captures/traffic.pcap -n
   ```

## Проблемы и их решения

В процессе разработки пришлось столкнуться с рядом технических сложностей:

### 1. Отказ от библиотеки gVisor

Изначально планировалось использовать библиотеку gVisor для модификации TCP-стека, но возникло множество проблем с совместимостью и зависимостями. Было принято решение перейти на прямые системные вызовы и команды для управления TCP-параметрами. Это сделало код более универсальным и менее подверженным проблемам версионирования.

### 2. Особенности работы в Docker

Запуск приложения в контейнере Docker требует дополнительных привилегий и настроек. В частности:
- Необходимо запускать контейнер с флагом `--privileged`
- Требуется добавить capability `NET_ADMIN` и `NET_RAW`
- Необходимо монтировать `/dev/net/tun` в контейнер

Кроме того, некоторые системные вызовы могут работать по-разному в контейнере и на хост-системе. Например, изменение `sysctl` параметров может быть ограничено в контейнере.

### 3. Активация TUN-интерфейса

TUN-интерфейс может создаваться в состоянии DOWN, что требует дополнительной активации:
```bash
ip link set tun0 up
ip addr add 10.0.0.1/24 dev tun0
```

### 4. Маршрутизация трафика

Настройка маршрутизации требует правильной последовательности команд и корректных значений IP-адресов. В некоторых случаях может потребоваться дополнительная настройка IP-forwarding и NAT.

## Результаты

После настройки и запуска приложения были получены следующие результаты:

1. Успешно создан и настроен TUN-интерфейс
2. Настройки TCP были изменены для имитации отпечатка Windows (отключены timestamps, настроен TTL и Window Size)
3. Настроены правила iptables для маркировки и перенаправления трафика
4. Захвачен сетевой трафик, демонстрирующий факт изменения TCP-параметров

## Заключение

Проект демонстрирует возможность кастомизации TCP-отпечатка и маршрутизации трафика через альтернативный интерфейс. Несмотря на отказ от библиотеки gVisor в пользу системных команд, все основные требования задания выполнены. Результаты могут быть использованы для создания систем анонимизации, тестирования безопасности или реализации специализированных сетевых прокси.
